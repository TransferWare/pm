/*
    The Performance Monitor monitors your Oracle databases.
    Copyright (C) 2002  G.J. Paulissen, Transfer Solutions b.v., Leerdam, Netherlands

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
REM $Header$
REM
REM  This ORACLE7 command file was generated by Oracle Server Generator
REM  Version 5.5.10.0.0 on 01-DEC-97
REM
REM For application GSK version 1 database GSK
REM
REM PACKAGE
REM      ACCESS  MESSAGES
REM      MUTATING AND CONSTRAINING TABLE PROBLEM
REM      VALUE IN REFERENCE-CODE DOMAIN

REM
REM     Circumvent mutating and constraining table problem
REM
PROMPT 
PROMPT Creating Package Specification gsk_mctp
CREATE OR REPLACE PACKAGE gsk_mctp IS
  --
  -- 
  TYPE rowid_tabtyp IS TABLE OF
  ROWID
  INDEX BY BINARY_INTEGER;
  --
  -- 
  TYPE binint_tabtyp IS TABLE OF
  BINARY_INTEGER
  INDEX BY BINARY_INTEGER;
  --
  -- Store rowid of mutated row in PL/SQL table
  PROCEDURE store_rowid(
  p_rowid IN rowid )
;
  --
  -- Determine whether rowid is of row mutated by current statement
  FUNCTION is_rowid_statmnt
RETURN boolean;
  --
  -- Clear seqno of first rowid and decrement seqno of current statement
  PROCEDURE reset_rowids_statmnt
;
  --
  -- Get and subsequently clear rowid of mutated row from PL/SQL table
  FUNCTION get_n_clear_rowid
RETURN rowid;
  --
  -- Increment seqno of current statement and store seqno of first rowid
  PROCEDURE init_rowids_statmnt
;
  --
  -- Check whether character-column value has really changed.
  FUNCTION column_changed(
  p_old_val IN VARCHAR2 ,
  p_new_val IN VARCHAR2 )
RETURN boolean;
  --
  -- Check whether number-column value has really changed.
  FUNCTION column_changed(
  p_old_val IN NUMBER ,
  p_new_val IN NUMBER )
RETURN boolean;
  --
  -- Check whether date-column value has really changed.
  FUNCTION column_changed(
  p_old_val IN DATE ,
  p_new_val IN DATE )
RETURN boolean;
END gsk_mctp;
/


REM
PROMPT 
PROMPT Creating Package Body gsk_mctp
CREATE OR REPLACE PACKAGE BODY gsk_mctp IS
  --
  -- 
  gt_statmnt_first_rowid_nos BININT_TABTYP;
  --
  -- 
  gt_rowids ROWID_TABTYP;
  --
  -- 
  gv_statmnt_no BINARY_INTEGER DEFAULT 0;
  --
  -- 
  gv_rowid_no BINARY_INTEGER DEFAULT 0;
  --
  -- Store rowid of mutated row in PL/SQL table
  PROCEDURE store_rowid(
  p_rowid IN rowid )
  IS
  BEGIN
    gv_rowid_no := gv_rowid_no + 1;
    gt_rowids( gv_rowid_no ) := p_rowid;
  END;
  --
  -- Determine whether rowid is of row mutated by current statement
  FUNCTION is_rowid_statmnt
  RETURN boolean IS
  BEGIN
    RETURN( gv_rowid_no >= gt_statmnt_first_rowid_nos( gv_statmnt_no ) );
  END;
  --
  -- Clear seqno of first rowid and decrement seqno of current statement
  PROCEDURE reset_rowids_statmnt
  IS
  BEGIN
    gt_statmnt_first_rowid_nos( gv_statmnt_no ) := null;
    gv_statmnt_no := gv_statmnt_no - 1;
  END;
  --
  -- Get and subsequently clear rowid of mutated row from PL/SQL table
  FUNCTION get_n_clear_rowid
  RETURN rowid IS
    v_rowid  rowid;
  BEGIN
    /* Get rowid. */
    v_rowid := gt_rowids( gv_rowid_no );
    /* Clear rowid. */
    gt_rowids( gv_rowid_no ) := null;
    gv_rowid_no := gv_rowid_no - 1;
    RETURN( v_rowid );
  END;
  --
  -- Increment seqno of current statement and store seqno of first rowid
  PROCEDURE init_rowids_statmnt
  IS
  BEGIN
    gv_statmnt_no := gv_statmnt_no + 1;
    gt_statmnt_first_rowid_nos( gv_statmnt_no ) := gv_rowid_no + 1;
  END;
  --
  -- Check whether character-column value has really changed.
  FUNCTION column_changed(
  p_old_val IN VARCHAR2 ,
  p_new_val IN VARCHAR2 )
  RETURN boolean IS
  BEGIN
    RETURN( ( p_old_val <> p_new_val )
            or
            ( p_old_val is null and p_new_val is not null )
            or 
            ( p_old_val is not null and p_new_val is null )
          );
  END;
  --
  -- Check whether number-column value has really changed.
  FUNCTION column_changed(
  p_old_val IN NUMBER ,
  p_new_val IN NUMBER )
  RETURN boolean IS
  BEGIN
    RETURN( ( p_old_val <> p_new_val )
            or
            ( p_old_val is null and p_new_val is not null )
            or 
            ( p_old_val is not null and p_new_val is null )
          );
  END;
  --
  -- Check whether date-column value has really changed.
  FUNCTION column_changed(
  p_old_val IN DATE ,
  p_new_val IN DATE )
  RETURN boolean IS
  BEGIN
    RETURN( ( p_old_val <> p_new_val )
            or
            ( p_old_val is null and p_new_val is not null )
            or 
            ( p_old_val is not null and p_new_val is null )
          );
  END;
END gsk_mctp;
/

REM
REM     Check whether given value is in given domain of reference code table
REM
PROMPT 
PROMPT Creating Package Specification gsk_refc
CREATE OR REPLACE PACKAGE gsk_refc IS
  --
  -- Checks whether given character value is in given domain
  FUNCTION value_in_domain(
  p_value IN varchar2 ,
  p_domain IN varchar2 )
RETURN boolean;
  --
  -- Checks whether given date value is in given domain
  FUNCTION value_in_domain(
  p_value IN date ,
  p_domain IN varchar2 ,
  p_format IN varchar2 := 'DD-MM-YYYY')
RETURN boolean;
  --
  -- Checks whether given number value is in given domain
  FUNCTION value_in_domain(
  p_value IN number ,
  p_domain IN varchar2 )
RETURN boolean;
END gsk_refc;
/


REM
PROMPT 
PROMPT Creating Package Body gsk_refc
CREATE OR REPLACE PACKAGE BODY gsk_refc IS
  --
  -- Checks whether given character value is in given domain
  FUNCTION value_in_domain(
  p_value IN varchar2 ,
  p_domain IN varchar2 )
  RETURN boolean IS
    cursor c_rfc is 
      select null 
      from   cg_ref_codes rfc 
      where  ( ( p_value = rfc.rv_low_value
                 and
                 rfc.rv_high_value is null ) 
               or 
               ( p_value between rfc.rv_low_value 
                             and rfc.rv_high_value ) 
             )
             and
             ( rfc.rv_domain = p_domain );
    v_dummy      varchar2(1);
    v_rfc_found  boolean;
  BEGIN
    open c_rfc; 
    fetch c_rfc into v_dummy; 
    v_rfc_found := c_rfc%found; 
    close c_rfc; 
    RETURN( v_rfc_found ); 
  END value_in_domain;
  --
  -- Checks whether given date value is in given domain
  FUNCTION value_in_domain(
  p_value IN date ,
  p_domain IN varchar2 ,
  p_format IN varchar2 := 'DD-MM-YYYY')
  RETURN boolean IS
    cursor c_rfc is 
      select null 
      from   cg_ref_codes rfc 
      where  ( ( p_value = to_date( rfc.rv_low_value, p_format )
                 and
                 rfc.rv_high_value is null ) 
               or 
               ( p_value between to_date( rfc.rv_low_value, p_format ) 
                             and to_date( rfc.rv_high_value, p_format ) ) 
             )
             and
             ( rfc.rv_domain = p_domain );
    v_dummy      varchar2(1);
    v_rfc_found  boolean;
  BEGIN
    open c_rfc; 
    fetch c_rfc into v_dummy; 
    v_rfc_found := c_rfc%found; 
    close c_rfc; 
    RETURN( v_rfc_found ); 
  END value_in_domain;
  --
  -- Checks whether given number value is in given domain
  FUNCTION value_in_domain(
  p_value IN number ,
  p_domain IN varchar2 )
  RETURN boolean IS
    cursor c_rfc is 
      select null 
      from   cg_ref_codes rfc 
      where  ( ( p_value = to_number( rfc.rv_low_value )
                 and
                 rfc.rv_high_value is null ) 
               or 
               ( p_value between to_number( rfc.rv_low_value ) 
                             and to_number( rfc.rv_high_value ) ) 
             )
             and
             ( rfc.rv_domain = p_domain );
    v_dummy      varchar2(1);
    v_rfc_found  boolean;
  BEGIN
    open c_rfc; 
    fetch c_rfc into v_dummy; 
    v_rfc_found := c_rfc%found; 
    close c_rfc; 
    RETURN( v_rfc_found ); 
  END value_in_domain;
END gsk_refc;
/

REM
REM     Access messages table
REM
PROMPT 
PROMPT Creating Package Specification gsk_msg
CREATE OR REPLACE PACKAGE gsk_msg IS
  --
  -- Get final form of message text in messages table
  FUNCTION get_final_message(
  p_std_format_message IN varchar2 )
RETURN varchar2;
  --
  -- Retrieve messages from messages table
  FUNCTION get_message_info(
  p_appl IN varchar2 ,
  p_nr IN number ,
  p_text IN OUT varchar2 ,
  p_alert_ind IN OUT varchar2 ,
  p_help_text IN OUT varchar2 )
RETURN boolean;
END gsk_msg;
/


REM
PROMPT 
PROMPT Creating Package Body gsk_msg
CREATE OR REPLACE PACKAGE BODY gsk_msg IS
  --
  -- Get final form of message text in messages table
  FUNCTION get_final_message(
  p_std_format_message IN varchar2 )
  RETURN varchar2 IS
  /*******************************************************************************
  CREATION
    Creator: Sjors Wagenaar
    Date:    22-02-1997
  FUNCTIONALITY
    Processes given standard-formatted message by retrieving message text from
    messages table and transforming it to its final form. This final-form message
    is returned.
    Substitution of a variable number of message parameters is supported.
  NOTES
    - If given message is not in standard format, it is simply returned.
    - Standard format of message:
          <appl>-<nnnnn> [<param ind><param value> <param ind><param value> ...]
      where <appl>        is application code
            <nnnnn>       is message number, including leading zeros
            <param ind>   is message-parameter indicator, for example ##
            <param value> is actual value of message parameter
      like in the following examples:
          GSK-00100
          GSK-00110 ##job
    - Parametrized message text in the messages table must contain
      parameter indicators at the appropriate positions, for example:
          Invalid value for ##.
    - Final form of message:
          <appl>-<nnnnn> <message text>
      like in:
          GSK-00110: Invalid value for job.
    - Message is truncated to 212 characters.
    - Assumptions for columns of messages table:
      - VARCHAR2(4) column containing application code
      - NUMBER(5) column containing message number
      - VARCHAR2(200) column containing message text
      - VARCHAR2(1) column containing alert indication
      - VARCHAR2(1000) column containing help on message
    - The declarations of some local varables are based on the assumptions above.
    - Other non-generic information is stored in constants.
    - A stored boolean function is used to get information from messages table.
      Therefore, no assumptions are made for table and column names.
      Note however, that the message help text and the alert indication retrieved
      by this function are not used.
  CALL
    Generic:    No (but see notes above)
    Restricted: No
    Parameters: p_message: message text
    Called:     Typically in raise_application_error in server-side PL/SQL
    Examples:   get_final_message( 'GSK-00100' )
                get_final_message( 'GSK-00110 ##job' )
                get_final_message( 'GSK-00120 ##' || to_char( :new.salary ) )
  HISTORY
  Date        Name      Description of change
  ----------  --------  ---------------------
  DD-MM-YYYY  USERNAME
  *******************************************************************************/
  
    cst_message_len           constant number(3) := 212;
    /* Applicaton code can be 2-4 characters long. */
    cst_min_hyphen_pos        constant number(1) := 3;
    cst_max_hyphen_pos        constant number(1) := 5;
    cst_msg_nr_len            constant number(1) := 5;
  
    v_message        varchar2(212);
    v_help_text      varchar2(1000);
    v_hyphen_pos     number(2);
    v_msg_appl       varchar2(4);
    v_msg_nr         varchar2(5);
    v_msg_tab_text   varchar2(200);
    v_alert_ind      varchar2(1);
  
    PROCEDURE subst_msg_tab_parameters
    /*****************************************************************************
    FUNCTIONALITY
      Replaces parameter indicators in given messages-table text with
      corresponding parameter values in specified message.
    NOTES
      - The procedure does nothing if specified message does not contain
        parameters
      - Assumptions:
        - parameters are indicated by exactly two special characters, e.g. ##
        - parameter indicator is not used in parameter values and message text
        - message contains parameter VALUES and is of general form:
            <string> <param ind><param value> <param ind><param value> ...
            example: GSK-00110 ##job
        - messages-table text contains parameter INDICATORS and is of general
          form:
            <string> <param ind> <string> <param ind> <string> ...
            example: Invalid value for ##.
      - Leading and trailing spaces of parameter values are removed
      - Parameter substitution is driven by given message,
        not by message text in messages table
    *****************************************************************************/
    ( p_message       in      varchar2
    , p_msg_tab_text  in out  varchar2
    )
    IS
  
      cst_param_ind         constant varchar2(2) := '##';
      cst_param_ind_len     constant number(1) := length( cst_param_ind );
      cst_msg_tab_text_len  constant number(3) := 200;
      v_message             varchar2(212);
      v_param_pos           number(3);
      v_param_val           varchar2(200);
  
    BEGIN
  
      /* Check whether message contains parameters. */
      v_param_pos := instr( p_message, cst_param_ind );
      if v_param_pos = 0 then
        return;
      end if;
  
      /* Strip string of parameter values from message.
         Remove first parameter indicator and append one at end to simplify
         algorithm. */
      v_message := substr( p_message, v_param_pos + cst_param_ind_len )
                   || cst_param_ind;
      while v_message is not null loop
        /* Get position of first parameter value in stripped message. */
        v_param_pos := instr( v_message, cst_param_ind );
        /* Get first parameter value and remove leading/trailing spaces. */
        v_param_val := ltrim( rtrim( substr( v_message, 1, v_param_pos - 1 ) ) );
        /* Strip first parameter value from message. */
        v_message := substr( v_message, v_param_pos + cst_param_ind_len );
        /* Get position of first parameter in messages-table text. */
        v_param_pos := instr( p_msg_tab_text, cst_param_ind );
        /* Replace first parameter indicator in messages-table text with
           parameter value. */
        p_msg_tab_text := substr( substr( p_msg_tab_text, 1, v_param_pos - 1 )
                                  || v_param_val
                                  || substr( p_msg_tab_text
                                           , v_param_pos + cst_param_ind_len )
                                , 1, cst_msg_tab_text_len );
      end loop;
  
    END subst_msg_tab_parameters;
  
  BEGIN -- get_final_message
  
    /* Initialize variable. */
    v_message := substr( p_std_format_message, 1, cst_message_len );
  
    /* Check whether message is standard-formatted message. */
    v_hyphen_pos := instr( v_message, '-' );
    if v_hyphen_pos not between cst_min_hyphen_pos and cst_max_hyphen_pos then
      /* Message not in standard format; simply return it. */
      RETURN( v_message );
    end if;
  
    /* Get message information from messages table by calling stored function.
       This boolean function returns TRUE if message exists in messages table.
       Note that message help text and alert indication retrieved by this function
       are not used. */
    v_msg_appl := substr( v_message, 1, v_hyphen_pos - 1 );
    v_msg_nr := substr( v_message, v_hyphen_pos + 1, cst_msg_nr_len );
    if get_message_info( v_msg_appl, to_number( v_msg_nr )
                       , v_msg_tab_text, v_alert_ind, v_help_text ) then
      /* Substitute possible message parameters. Note that message contains
         parameter values and messages-table text contains parameter
         indicators. */
      subst_msg_tab_parameters( v_message, v_msg_tab_text );
      /* Construct final message. */
      v_message := v_msg_appl || '-' || v_msg_nr || ': '|| v_msg_tab_text;
    else
      /* Message not found in messages table. */
      v_message := 'Unknown message ' || v_msg_appl || '-' || v_msg_nr
                   || '. Please inform your support person.';
    end if;
  
    RETURN( v_message );
  
  END get_final_message;
  --
  -- Retrieve messages from messages table
  FUNCTION get_message_info(
  p_appl IN varchar2 ,
  p_nr IN number ,
  p_text IN OUT varchar2 ,
  p_alert_ind IN OUT varchar2 ,
  p_help_text IN OUT varchar2 )
  RETURN boolean IS
  /*******************************************************************************
  CREATION
    Creator: Sjors Wagenaar
    Date:    01-08-1996
  FUNCTIONALITY
    Retrieves message text, alert indication, and help-on-message text
    for given application code and message number from a messages table.
  NOTES
    -
  CALL
    Generic:  No (depends on messages table)
    Examples: v_msg_found := get_message_info( v_appl, v_nr, v_text
                                             , v_alert_ind
                                             , v_help_text );
  HISTORY
  Date        Name      Description of change
  ----------  --------  ---------------------
  DD-MM-YYYY  USERNAME
  *******************************************************************************/
    cursor c_msg is
      select msg.tekst 
      ,      msg.alert_ind 
      ,      msg.help_tekst 
      from   gsk_meldingen msg 
      where  msg.appl = p_appl 
        and  msg.nr   = p_nr;
    v_msg_found  boolean;
  BEGIN
    open c_msg; 
    fetch c_msg into p_text 
    ,                p_alert_ind 
    ,                p_help_text; 
    v_msg_found := c_msg%found; 
    close c_msg; 
    RETURN( v_msg_found ); 
  END get_message_info;
END gsk_msg;
/

