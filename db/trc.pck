/*
    The Performance Monitor monitors your Oracle databases.
    Copyright (C) 2002  G.J. Paulissen, Transfer Solutions b.v., Leerdam, Netherlands

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
PROMPT
PROMPT  $Id$
REMARK 
REMARK  $Date$
REMARK
REMARK  $Author$
REMARK
REMARK  $Revision$
REMARK
REMARK  Description:    Create trace package of Performance Monitor.
REMARK
REMARK  $Log$
REMARK  Revision 1.3  2004/12/15 11:22:05  gpaulissen
REMARK  New release
REMARK
REMARK  Revision 1.2  2004/12/14 17:12:08  gpaulissen
REMARK  [ 828145 ] Unit test of trc fails
REMARK
REMARK  Revision 1.1  2003/08/28 14:44:48  gpaulissen
REMARK  Release 6.0.0
REMARK
REMARK  Revision 1.15  2002/12/22 19:55:12  gpaulissen
REMARK  Geen database link meer nodig.
REMARK
REMARK  Revision 1.14  2002/05/24 14:22:51  gpaulissen
REMARK  New release 4.1.0
REMARK
REMARK  Revision 1.13  2002/02/01 10:59:56  gpaulissen
REMARK  New make environment
REMARK
REMARK  Revision 1.12  2002/01/17 10:57:11  gpaulissen
REMARK  - make install enhanced.
REMARK  - make depend added (makedepend_oracle.pl, makedepend.sql, makestate.sql).
REMARK  - reports user text field widened (from 10 to 30) due to report 4.5 bug.
REMARK  - removed in install scripts:
REMARK    whenever sqlerror exit failure
REMARK    whenever oserror exit failure
REMARK
REMARK  Revision 1.11  1999/10/20 13:01:56  gpaulissen
REMARK  Added WHENEVER SQLERROR/OSERROR CONTINUE
REMARK
REMARK  Revision 1.10  1999/10/07 13:18:02  gpaulissen
REMARK  PR-777 WHENEVER SQLERROR/OSERROR
REMARK
REMARK  Revision 1.9  1999/10/01 15:15:35  gpaulissen
REMARK  PR-736 Version info added
REMARK
REMARK  Revision 1.8  1999/09/13 12:39:42  gpaulissen
REMARK  Added pod documentation
REMARK
REMARK  Revision 1.7  1999/09/09 12:35:29  gpaulissen
REMARK  Added debugging info.
REMARK
REMARK  Revision 1.6  1999/08/10 13:14:18  gpaulissen
REMARK  Added version function.
REMARK
REMARK  Revision 1.5  1999/07/09 09:32:22  gpaulissen
REMARK  Better debugging support. Problem with command type solved.
REMARK
REMARK  Revision 1.4  1999/06/25 11:43:19  gpaulissen
REMARK  Added dbug statements.
REMARK
REMARK  Revision 1.4  1999/06/10 21:34:26  gpaulissen
REMARK  Using dbug package.
REMARK
REMARK  Revision 1.3  1999/05/27 18:47:25  gpaulissen
REMARK  Portable for Oracle 7.2 or lower.
REMARK
REMARK  Revision 1.2  1999/05/25 14:45:14  gpaulissen
REMARK  Released
REMARK
REMARK  Revision 1.1  1999/04/15 14:23:48  gpaulissen
REMARK  Initial revision
REMARK

REM
REM  This ORACLE7 command file was generated by Oracle Server Generator
REM  Version 5.5.10.0.0 on 15-APR-99
REM
REM For application PM version 1 database PM
REM
REM PACKAGE
REM      TRC

PROMPT Creating Package Specification trc

SET DOCUMENT OFF

DOCUMENT

The following documentation uses the Perl pod format. A html file
can be constructed by: 

  pod2html --infile=trc.pck --outfile=trc.html

=pod

=head1 NAME

trc - Trace program execution and save error info

=head1 SYNOPSIS

=cut

#

-- =pod

CREATE OR REPLACE PACKAGE trc IS

pragma restrict_references( trc, rnds, wnds );

  -- Start tracing a module
  PROCEDURE enter(
  i_proc_name  VARCHAR2)
;
  --
  -- Stop tracing a module
  PROCEDURE leave
;
  --
  -- Get a trace call list separated  by new lines
  FUNCTION get_calls(
  i_pos IN INTEGER := 1,
  i_length IN INTEGER := NULL)
RETURN VARCHAR2;
  --
  -- Stop tracing a module in the event of an exception
  PROCEDURE leave_on_error(
  i_error_msg in varchar2 default SQLERRM,
  i_format_call_stack in varchar2 default dbms_utility.format_call_stack,
  i_calls in varchar2 default trc.get_calls)
;
  --
  -- Get a trace module comma separated list
  FUNCTION get_modules(
  i_pos IN INTEGER := 1,
  i_length IN INTEGER := NULL)
RETURN VARCHAR2;
  --
  -- Get the error message during the first exception in a row.
  FUNCTION get_first_error_msg
RETURN VARCHAR2;
  --
  -- Get the dbms_utility.format_call_stack during the first exception in a row.
  FUNCTION get_first_format_call_stack
RETURN VARCHAR2;
  --
  -- Get the trace call list during the first exception in a row.
  FUNCTION get_first_calls
RETURN VARCHAR2;
  --
  -- Add an argument
  PROCEDURE add_arg(
  i_descr  VARCHAR2 ,
  i_value  NUMBER)
;
  --
  -- Add an argument
  PROCEDURE add_arg(
  i_descr  VARCHAR2 ,
  i_value  VARCHAR2)
;
  --
  -- Add an argument
  PROCEDURE add_arg(
  i_descr  VARCHAR2 ,
  i_value  DATE)
;
  --
  -- Add an argument
  PROCEDURE add_arg(
  i_descr  VARCHAR2 ,
  i_value  BOOLEAN)
;
  --
  -- Initialise a trace thread
  PROCEDURE init
;

  PROCEDURE set_enable_call_stack( i_value IN BOOLEAN )
;

  FUNCTION get_enable_call_stack
  RETURN BOOLEAN
;

function version return varchar2;

pragma restrict_references( version, rnds, wnds );

END trc;

-- =cut

/

DOCUMENT

=head1 DESCRIPTION

The I<trc> package is used for tracing program execution: a list of calls is
stored as well as debugging output the first time an exception is handled.

This package is very useful to trace where and why an exception has
occurred: the trace call stack at the time of the first exception is stored,
as well as the I<SQLERRM> message and the I<dbms_utility.format_call_stack>. 

To be able to get all this information the application has to be designed in
such a way that (important) routines use a similar protocol: entering the
routine must be registered (as well as the important input
parameters). Leaving the routine must also be registered. Leaving the routine
in an exception block is special: now the exception may be flagged as the
first exception in a row. Returning a routine is only allowed when the
registration is complete: each enter must be accompanied by a leave.

=head2 ROUTINES

=over 4

=item enter

Register a routine call and adds I<i_module_name> to the call stack. The
parameter I<i_module_name> should be unique. Use <package name>.<routine name>
packages.  The parameters may be added to the call stack list by C<add_arg>. Each
I<enter> must be unregistered by either C<leave> or C<leave_on_error>.

=item leave

Unregister a routine call. 

=item leave_on_error

Unregister a routine call in an exception block. The first call to
leave_on_error saves debugging information. So leave_on_error followed
by leave_on_error and another leave_on_error saves debugging info of
the first leave_on_error. But leave_on_error followed by leave and
then leave_on_error saves debugging info of the last leave_on_error

Default parameters are SQLERRM for I<i_error_msg> and dbms_utility.format_call_stack for I<i_format_call_stack>.

=item get_calls

Get the call stack starting at position I<i_pos> of length I<i_length>. If
i_pos is 0, it is treated as 1. If i_pos is positive, it counts from the first
call to find the position i_pos. If i_pos is negative, it counts backwards
from the end of the call stack. If i_length is omitted, all calls to the end
are returned. If i_length is less than 1, an empty range is returned.

=item get_modules

Get the module stack starting at position I<i_pos> of length I<i_length>. See also C<get_calls>.

=item get_first_error_msg

Get the error message saved at the first call to C<leave_on_error>.

=item get_first_format_call_stack

Get the format_call_stack saved at the first call to C<leave_on_error>.

=item get_first_calls

Get the call stack saved at the first call to C<leave_on_error>.

=item add_arg

Add additional info for a call. Used for showing the value of a
parameter. Currently only numbers, strings, dates or booleans are supported.

=item init

Initialise the trc package. Only needed when the call stack gets corrupt.

=item set_enable_call_stack

Enable tracing of the call stack, which is on by default.

=item get_enable_call_stack

Return call stack tracing enabled.

=item version

Return versioning info of this package.

=back

=head1 EXAMPLES

=head2 Wrong

        procedure return_too_soon( i_test in boolean )
        is
        begin
                trc.enter( 'return_too_soon' );
                if      i_test
                then
                        return; -- wrong: must call trc.leave first
                end if;
                trc.leave;
        exception
                when    others
                then
                        trc.leave_on_error;
        end;

=head2 Divide by zero

        declare
                function
                divide (i_a in integer, i_b in integer)
                return  integer
                is
                        v_value integer;
                begin
                        trc.enter( 'divide' );
                        trc.add_arg( 'i_a', i_a );
                        trc.add_arg( 'i_b', i_b );
                        v_value := i_a / i_b;
                        trc.leave;
                        RETURN (v_value);
                exception
                        when    others
                        then
                                trc.leave_on_error;
                                RAISE;
                end;
        begin
                dbms_output.enable( 10000 );
                trc.enter( 'main' );
                dbms_output.put_line( divide( 10, 5 ) );
                dbms_output.put_line( divide( 10, 0 ) );
                trc.leave;
        exception
                when    others
                then
                        trc.leave_on_error;
                        dbms_output.put_line( '*** trc.get_first_error_msg ***' );
                        dbms_output.put_line( trc.get_first_error_msg );
                        dbms_output.put_line( '*** trc.get_first_calls ***' );
                        dbms_output.put_line( trc.get_first_calls );
                        dbms_output.put_line( '*** trc.get_first_format_call_stack ***' );
                        dbms_output.put_line( trc.get_first_format_call_stack );
        end;

        This example should produce this kind of output:

        2
        *** trc.get_first_error_msg ***
        ORA-01476: divisor is equal to zero
        *** trc.get_first_calls ***
        main;
        divide(10,5);
        *** trc.get_first_format_call_stack ***
        ----- PL/SQL Call Stack -----
          object      line  object
          handle    number
        name
         2582788        17  anonymous block
         2582788        24  anonymous block

=head1 AUTHOR

Gert-Jan Paulissen, E<lt>gpaulissen@transfer-solutions.comE<gt>.

=head1 BUGS

=head1 SEE ALSO

=head1 COPYRIGHT

All rights reserved by Transfer Solutions b.v.

=cut

#

REM
PROMPT 
PROMPT Creating Package Body trc
CREATE OR REPLACE PACKAGE BODY trc IS
  v_proc_name_dummy VARCHAR2(60);
  v_nr_values_dummy INTEGER;
  v_value_list_dummy VARCHAR2(2000);

  SUBTYPE proc_name_t IS v_proc_name_dummy%TYPE;
  SUBTYPE nr_values_t IS v_nr_values_dummy%TYPE;
  SUBTYPE value_list_t IS v_value_list_dummy%TYPE;

  TYPE call_info_rt IS RECORD
  (
  proc_name proc_name_t,
  nr_values nr_values_t NOT NULL  DEFAULT 0,
  value_list value_list_t);
  --
  -- 
/*  TYPE call_info_tt IS TABLE OF
  trc.call_info_rt
  INDEX BY BINARY_INTEGER;
*/
  TYPE proc_name_tt IS TABLE OF
  proc_name_t
  INDEX BY BINARY_INTEGER;
  -- 
  TYPE nr_values_tt IS TABLE OF
  nr_values_t
  INDEX BY BINARY_INTEGER;
  --
  TYPE value_list_tt IS TABLE OF
  value_list_t
  INDEX BY BINARY_INTEGER;
  --
/*  t_call_info call_info_tt; */

  v_call_info_count INTEGER := 0;
  t_proc_name proc_name_tt;
  t_nr_values nr_values_tt;
  t_value_list value_list_tt;

  t_proc_name_empty proc_name_tt;
  t_nr_values_empty nr_values_tt;
  t_value_list_empty value_list_tt;
  --
  -- Current call
  r_curr_call_info call_info_rt;
  --
  -- 
  v_last_descr VARCHAR2(60);
  --
  -- 
  v_enable_call_stack boolean default true;


  v_first_error_msg varchar2(32767) := NULL;
  v_first_format_call_stack varchar2(32767) := NULL;
  v_first_calls varchar2(32767) := NULL;
  --
  -- Add a value to the value list
  PROCEDURE add_value(
  i_descr  VARCHAR2 ,
  i_value  VARCHAR2 )
;
  --
  -- Get a range
  PROCEDURE get_range(
  i_pos IN INTEGER ,
  i_length IN INTEGER ,
  o_lwb OUT INTEGER ,
  o_upb OUT INTEGER )
;
  --
  -- Clear a call info record
  PROCEDURE clear(
  o_call_info OUT trc.call_info_rt)
;
  --
  PROCEDURE set_call_info( i_call_info IN call_info_rt, i_index IN INTEGER )
  IS
  BEGIN
    t_proc_name( i_index ) := i_call_info.proc_name;
    t_nr_values( i_index ) := i_call_info.nr_values;
    t_value_list( i_index ) := i_call_info.value_list;
  END;
  --
  PROCEDURE push_call_info( i_call_info IN call_info_rt )
  IS
  BEGIN
    v_call_info_count := v_call_info_count + 1;
    set_call_info( i_call_info, v_call_info_count );
  END;
  --
  PROCEDURE pop_call_info
  IS
  BEGIN
    v_call_info_count := v_call_info_count - 1;
    IF  v_call_info_count = 0
    THEN
      t_proc_name := t_proc_name_empty;
      t_nr_values := t_nr_values_empty;
      t_value_list := t_value_list_empty; 
    END IF;
  END;
  --
  FUNCTION exists_call_info( i_index IN INTEGER )
  RETURN BOOLEAN
  IS
  BEGIN
    RETURN i_index > 0;
  END;
  --
  FUNCTION get_call_info( i_index IN INTEGER )
  RETURN call_info_rt
  IS
    r_call_info call_info_rt;
  BEGIN
    r_call_info.proc_name := t_proc_name( i_index );
    r_call_info.nr_values := t_nr_values( i_index );
    r_call_info.value_list := t_value_list( i_index );
    RETURN r_call_info;
  END;

  -- Start tracing a module
  PROCEDURE enter(
  i_proc_name  VARCHAR2)
  IS
  BEGIN
        clear( r_curr_call_info );
        r_curr_call_info.proc_name := i_proc_name;

--/*DBUG*/      dbug.enter( 
--/*DBUG*/              r_curr_call_info.proc_name
--/*DBUG*/      );

        IF      v_enable_call_stack = true
        THEN
                push_call_info( r_curr_call_info );
                v_last_descr := NULL;
        END IF;
    
        dbms_application_info.set_module( i_proc_name, NULL );
    EXCEPTION
        WHEN    OTHERS
        THEN
                NULL;
    
  END;
  --
  -- Stop tracing a module
  PROCEDURE leave
  IS
  BEGIN
        leave_on_error( NULL, NULL, NULL );
  END;
  --
  -- Stop tracing a module in the event of an exception
  PROCEDURE leave_on_error(
  i_error_msg in varchar2,
  i_format_call_stack in varchar2,
  i_calls in varchar2)
  IS
  BEGIN
--/*DBUG*/      dbug.leave;

        if      i_error_msg is not null
        then
                if      v_first_error_msg is null
                then
                        v_first_error_msg := i_error_msg;
                        v_first_format_call_stack := i_format_call_stack;
                        v_first_calls := i_calls;
                end if;
        else
                v_first_error_msg := NULL;
                v_first_format_call_stack := NULL;
                v_first_calls := NULL;
        end if;

        IF      v_enable_call_stack = true
        THEN
                IF      v_call_info_count > 0
                THEN
                        pop_call_info;
                END IF;
                v_last_descr := NULL;
        END IF;

        IF      exists_call_info( v_call_info_count )
        THEN
                r_curr_call_info := get_call_info( v_call_info_count );
        ELSE
                clear( r_curr_call_info );
        END IF;
    
        dbms_application_info.set_module
        (
                r_curr_call_info.proc_name 
        ,       NULL
        );
    EXCEPTION
        WHEN    OTHERS
        THEN
                NULL;
    END;
  --
  -- Get a trace call list separated  by new lines
  FUNCTION get_calls(
  i_pos IN INTEGER := 1,
  i_length IN INTEGER := NULL)
  RETURN VARCHAR2 IS
    --
    -- 
    v_lwb INTEGER;
    --
    -- 
    v_upb INTEGER;
    --
    -- 
    v_call VARCHAR2(2000);
    --
    -- 
    r_call_info trc.call_info_rt;
    --
    -- 
    v_call_list VARCHAR2(2000);
  BEGIN
        v_call := NULL;
        v_call_list := NULL;
        get_range( i_pos, i_length, v_lwb, v_upb );
    
        FOR     v_idx IN v_lwb .. v_upb
        LOOP
                    r_call_info := get_call_info(v_idx);
                    v_call := r_call_info.proc_name;
    
                    IF      r_call_info.nr_values <> 0
                    THEN
                            v_call := 
                                    v_call || 
                                    '(' || 
                                    r_call_info.value_list || 
                                    ')';
                    END IF;
        
                    v_call := v_call || ';';
                    IF      v_idx = v_lwb
                    THEN
                            v_call_list := v_call;
                    ELSE
                            v_call_list := v_call_list || CHR(10) || v_call;
                    END IF;
    
            END LOOP;
        
        RETURN  v_call_list;
    EXCEPTION
            WHEN    OTHERS
            THEN
                    RETURN  v_call_list;
  END;
  --
  -- Get a trace module comma separated list 
  FUNCTION get_modules(
  i_pos IN INTEGER := 1,
  i_length IN INTEGER := NULL)
  RETURN VARCHAR2 IS
    --
    -- 
    v_lwb INTEGER;
    --
    -- 
    v_upb INTEGER;
    --
    r_call_info trc.call_info_rt;
    -- 
    v_module_list VARCHAR2(2000);
  BEGIN
        v_module_list := NULL;
            get_range( i_pos, i_length, v_lwb, v_upb );
        
            FOR     v_idx IN v_lwb .. v_upb
            LOOP
                    r_call_info := get_call_info(v_idx);
                    IF      v_idx = v_lwb
                    THEN
                            v_module_list := r_call_info.proc_name;
                    ELSE
                            v_module_list := 
                                    v_module_list || ',' || 
                                    r_call_info.proc_name;
                    END IF;
            END LOOP;
        
            RETURN  v_module_list;
        EXCEPTION
            WHEN    OTHERS
            THEN
                    RETURN  v_module_list;
  END;
  --
  -- Get the error message during the first exception in a row.
  FUNCTION get_first_error_msg
  RETURN VARCHAR2
  IS
  BEGIN
        RETURN  v_first_error_msg;
  END;
  --
  -- Get the dbms_utility.format_call_stack during the first exception in a row.
  FUNCTION get_first_format_call_stack
  RETURN VARCHAR2
  IS
  BEGIN
        RETURN  v_first_format_call_stack;
  END;
  --
  -- Get the trace call list during the first exception in a row.
  FUNCTION get_first_calls
  RETURN VARCHAR2
  IS
  BEGIN
        RETURN  v_first_calls;
  END;
  --
  -- Add an argument
  PROCEDURE add_arg(
  i_descr  VARCHAR2 ,
  i_value  NUMBER)
  IS
  BEGIN
        IF      v_enable_call_stack = true
        THEN    
                add_value( i_descr, TO_CHAR(i_value) );
        END IF;
    
--/*DBUG*/      dbug.print( 'input', i_descr || ': ' || i_value );

    EXCEPTION
        WHEN    OTHERS
        THEN
                NULL;
    
  END;
  --
  -- Add an argument
  PROCEDURE add_arg(
  i_descr  VARCHAR2 ,
  i_value  VARCHAR2)
  IS
  BEGIN
        IF      v_enable_call_stack <> true
        THEN
                NULL;
        ELSIF   i_value IS NULL
        THEN
                add_value( i_descr, NULL );
        ELSE
                        /* 
                         *      A string has to show up as 'string'. 
                         *      Mind  the quotes already in string 
                         */
                add_value( i_descr, '''' || REPLACE(i_value, '''', '''''') || '''' );
        END IF;
    
--/*DBUG*/      dbug.print( 'input', i_descr || ': ' || i_value );
    EXCEPTION
        WHEN    OTHERS
        THEN
                NULL;
    
  END;
  --
  -- Add an argument
  PROCEDURE add_arg(
  i_descr  VARCHAR2 ,
  i_value  DATE)
  IS
  BEGIN
        IF      v_enable_call_stack <> true
        THEN
                NULL;
        ELSIF   i_value IS NULL
        THEN
                add_value( i_descr, NULL );
        ELSE
                        /* 
                         *      A date has to show up as 'YYYY-MM-DD HH24:MI:SS'. 
                         */
                add_value
                ( 
                        i_descr
                ,       '''' || 
                        TO_CHAR(i_value, 'YYYY-MM-DD HH24:MI:SS') || 
                        ''''
                );
        END IF;
    
--/*DBUG*/      dbug.print( 
--/*DBUG*/              'input', 
--/*DBUG*/              i_descr || ': ' ||
--/*DBUG*/              TO_CHAR(i_value, 'YYYY-MM-DD HH24:MI:SS') 
--/*DBUG*/      );

    EXCEPTION
        WHEN    OTHERS
        THEN
                NULL;
    
  END;
  --
  -- Add an argument
  PROCEDURE add_arg(
  i_descr  VARCHAR2 ,
  i_value  BOOLEAN)
  IS
  BEGIN
        IF      v_enable_call_stack <> true
        THEN
                NULL;
        ELSIF   i_value IS NULL
        THEN
                add_value( i_descr, NULL );
        ELSIF   i_value
        THEN
                add_value( i_descr, 'TRUE' );
        ELSE
                add_value( i_descr, 'FALSE' );
        END IF;
    
--/*DBUG*/      dbug.print( 'input', i_descr || ': %s', i_value );
    EXCEPTION
        WHEN    OTHERS
        THEN
                NULL;
    
  END;
  --
  -- Add a value to the value list
  PROCEDURE add_value(
  i_descr  VARCHAR2 ,
  i_value  VARCHAR2 )
  IS
  BEGIN
                /* Same field ? */
        IF      i_descr = v_last_descr
        THEN
                NULL;
        ELSE
                IF      r_curr_call_info.nr_values = 0
                THEN
                        r_curr_call_info.value_list := nvl(i_value,'NULL');
                ELSE
                        r_curr_call_info.value_list := 
                                r_curr_call_info.value_list || ',' || 
                                nvl(i_value,'NULL');
                END IF;
    
                r_curr_call_info.nr_values := r_curr_call_info.nr_values + 1;
    
                set_call_info(r_curr_call_info, v_call_info_count);
        END IF;
    
        v_last_descr := i_descr;
    
  END;
  --
  -- Get a range
  PROCEDURE get_range(
  i_pos IN INTEGER ,
  i_length IN INTEGER ,
  o_lwb OUT INTEGER ,
  o_upb OUT INTEGER )
  IS
    --
    -- 
    v_lwb INTEGER;
    --
    -- 
    v_upb INTEGER;
  BEGIN
    /*
        This procedure returns a range, beginning at call i_pos, i_length
        calls long. 
        
        If i_pos is 0, it is treated as 1. 
        If i_pos is positive, it counts from the first call to find the
        position i_pos. 
        If i_pos is negative, it counts backwards from the end of the call
        stack. 
        If i_length is omitted, all calls to the end are returned.
        If i_length is less than 1, an empty range is returned.
    
        Note: the range is an inclusive range. i.e. including bounds
    */
    
        IF      i_pos >= 0
        THEN
                v_lwb := greatest(1, i_pos);
        ELSE
                    /* i_pos < 0 */
                        /* -1 is the last entry, hence add 1 */
                v_lwb := v_call_info_count + i_pos + 1;
        END IF;
        
        IF      i_length IS NULL
        THEN
                v_upb := v_call_info_count;
        ELSIF   i_length < 1
        THEN
                v_upb := v_lwb - 1; /* empty range */
        ELSE            
                v_upb := least(v_lwb + i_length - 1, v_call_info_count);
        END IF;
        
        o_lwb := v_lwb;
        o_upb := v_upb;
    EXCEPTION
        WHEN    OTHERS
        THEN
                        /* return an empty range */
                o_lwb := 1;
                o_upb := 0;
  END;
  --
  -- Initialise a trace thread
  PROCEDURE init
  IS
  BEGIN
    v_call_info_count := 0;
    v_first_error_msg := NULL;
    v_first_format_call_stack := NULL;
    v_first_calls := NULL;

    t_proc_name := t_proc_name_empty;
    t_nr_values := t_nr_values_empty;
    t_value_list := t_value_list_empty; 
    v_last_descr := NULL;
    clear( r_curr_call_info );
  EXCEPTION
    WHEN OTHERS
    THEN
      NULL;
  END;
  --
  -- Clear a call info record
  PROCEDURE clear(
  o_call_info OUT trc.call_info_rt)
  IS
  BEGIN
        o_call_info.proc_name := NULL;
        o_call_info.nr_values := 0;
        o_call_info.value_list := NULL;
  END;

  PROCEDURE set_enable_call_stack( i_value IN BOOLEAN )
  IS
  BEGIN
    v_enable_call_stack := i_value;
  END;

  FUNCTION get_enable_call_stack
  RETURN BOOLEAN
  IS
  BEGIN
    RETURN v_enable_call_stack;
  END;

/* return either the (value of) keyword Name or Revision */
function version 
return varchar2
is
        v_keyword varchar2(100) := NULL;
        v_length integer;
        v_pos integer;
        v_result v_keyword%type := NULL;
begin
        for nr in 1..2
        loop
                if      nr = 1
                then
                        v_keyword := '$Name$';
                        v_length := 9; /* length with a ':  ' after Name */
                else
                        v_keyword := '$Revision$';
                        v_length := 13; /* length with a ':  ' after Revision */
                end if;

                v_pos := instr( v_keyword, ':' );
                      /* If the characters following keyword are ':  ' then skip */
                if ( v_pos > 0 and length(v_keyword) > v_length )
                then
                        v_result := substr( v_keyword, v_pos + 2, length( v_keyword ) - v_length );
                        exit;
                end if;
        end loop;

        return  v_result;
exception
        when    others
        then
                return  NULL;
end;

BEGIN
        v_last_descr := NULL;
--      clear( r_curr_call_info );
END;
/


